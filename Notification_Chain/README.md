# Notification Chains
This Project Implement the Notification Chain Architecture Demo.
All implementation and notes taken from Udemy course [**Multithreading & Thread Synchronization - C/C++**](https://www.udemy.com/course/multithreading_parta/#instructor-1) 
Purpose of this project to practice and summarize the implementation of Notification Chain Architecture, so it may have some bugs, dump implementation, and poor design.

## Notification Chain Introduction
Architectural concept used to notify multiple subscribers interested in the particular event.

 A party which generate event is called publisher, and partied which are interested in being notified called subscribers.

- There are one publisher and multiple subscribers.
- Once event generated by the publisher, it pushed to the subscribers
- Subscriber can register and de-register for the event at they wants.
- Publisher/Subscribers can could be:
    - Multiple threads of the same process
    - Multiple processes running on the same system or different system
    - Different components of the same big software system.

this architecture is important and used alot in communication pattern in the in industry

## NFC - Pictorial Representation

- Publisher have the source data
- Subscribers can be many and the are independent to each other.
- If subscriber is interested on some data in publisher
    - subscriber will send subscription request to the publisher, please notify me if any modification related to this data using this function pointer.
    - publisher will create entry in its notification chain which have:
        - key → data type the subscriber is interested on
        - callback function of the subscriber.
- if a subscriber is interested on all of the data in the publisher
    - the publisher will create entry in the notification chain:
        - <no key>
        - callback function of the subscriber.
- When the publisher update a particular entry in the data source
    - it will iterate in all notification chain and call the callback of the subscriber with matching entry.

## NFC - Implementation
### Subscription Request Implementation

here we just add the `notfi_chain_elemnt` to the notification data structure:

- make local pointer of `notif_chain_elemnt` and allocate memory
- copy the data in the args to out local pointer
- add the local pointer to the data structure

### Invoke Request Implementation

- Iterate over the notification chain element
- check the key if the element
    - if the key is not set means it is a wildcard
        - we invoke it to in every element
    - if the key is set
        - we invoke it when the key matches with the element in notification chain data structure.


## NFC - Publisher Subscriber Model

Now We have implemented a basic skeleton framework for Notification Chains, We will use it to implement actual publisher subscriber model

- We will have 1 Publisher Thread
    - data source is a **routing table**.
    - Destination IP and Mask field will be the keys.
    - Outgoing interface name and Gateway will act as other data.
    - Publisher Thread will be in charge of the 4 data mentioned above, which it is a **Routing Table**.
    - each data entry must have its own notification chain, which is a linked list of subscribers.
- We will have 3 Subscriber Threads
    - A subscriber can register to multiple entries to the **routing table**
    - A subscriber can subscribe/unsubscribe at his will

## Setting up a Data source - Routing Table

- first we need to make routing table data structure.
- We need to make APIs which will create, modify,, etc. the routing table

So the implementation will be:

- Identify the key for the routing table struct `rt_entry_keys` which consist of
    - `char[16] Dest_ip` → Destination IP.
    - `char mask` → Mask
- Identify the routing table entry data struct `rt_entry` which consist of
    - `rt_entry_keys rt_entry_keys` → routing table entry key
    - `char oif[32]` → out interface name data field.
    - `char gw_ip[16]` → gateway IP data field
    - Also we will have next and previous pointer → to form the routing table as a doubly linked list, this is NOT about notification chain data structure just to save the routing table data as data structure, We can use instead of linked list an array to form the routing table but the issue it will be constant size.
    - Later we will use the notification chain data structure to organize subscribers.
- Lastly Identify the routing table linked list to form the routing table.

The APIs:

- routing table initializer
- routing table add entry
- delete routing table entry
- fetch routing table entry
- delete routing table

## Setting Up the Publisher

We start implement the publisher `rtm_publisher.c`
This file have the main function.
We will create 3 `Subscriber` threads as mentioned in the picture above.

`rt_table_t` routing table, will be global variable and owned by the `publisher` thread.

- We will have an API to return the routing table → `rt_table_t *publisher_get_rt_table()`
    - basically return the routing table
- Initialize the routing table, using routing table initializer API that we implemented → `rt_init_rt_table()`
- We will create the publisher thread → we need to create an API for it
    - publisher thread will be in `detached` mode.
    - `void create_publisher_thread()`
        - this API will assign the publisher thread to a callback function
        - the call back function will fill the routing table with initial values for demo → `void *publisher_thread_fn(void *arg)`
            - filling the routing table using the API we implemented → `rt_add_or_update_rt_entry()`
            - display the routing table to check the demo using the API we implemented → `rt_dump_rt_table()`
            - then the publisher thread will enter to infinite loop display menu for user interaction, we will implement this API → `main_menu()`
                - this main menu will go through an infinite loop
                - take input from user
                - parse the input and perform the action
                - actions will be
                    1. add/update routing table
                    2. delete routing table entry
                    3. Dump routing table
## Setting up The Subscriber

We have implemented publisher thread, which it have the main function.
Now we will implement the Subscriber thread `thread_subscriber.c`
We most implement these APIs

- `void create_subscriber_thread(uint32_t client_id)`
    - create the subscriber thread and give it client id.
    - thread will be in detached mode
    - thread callback is   `void *subscriber_thread_fn(void *arg)`
- `void *subscriber_thread_fn(void *arg)`
    - allow the subscriber to subscribe to random data source entry
    - we need to use the data entry key `rt_entry_key_t`
    - fill keys with random values
    - call `rt_table_register_for_notification()` API → which we need to implement this API
    - we will register with 3 routing table entry in this example.
    - pause the subscriber thread don't terminate using `pause()`
- `static void test_cb(void *arg, size_t arg_size, nfc_op_t nfc_op_code, uint32_t client_id)`
    - this function will be called in publisher Notification chain, to inform the subscriber about any update in the routing table entry
    - IMPORTANT TO NOTE - Prototype of this function must match with function pointer in `notification_chain_element_t`, so the publisher can notify the subscriber through this function
    - this function declared as `static`, to be saved in memory and not be discarded, because it will be used as argument to other function I assume.
    - this function will be passed as argument in subscriber registration in notification chain API.
        - print the subscriber thread details
            - client id
            - function name
            - notification chain op code (update type).

## Subscription and Notification

Now our framework implemented:
- publisher thread
- data source → owned by the publisher thread and can modify it
- a subscriber thread

So we will implement the subscription

### Subscription

Allow Subscribers to subscribe or unsubscribe for the entry of interest for notifications.

### Notification

Notify the subscribers whenever the entry in the data source is updated by the publisher

## Implementing Subscription
Subscriber will register to data entry of interest, by calling registration function `void rt_table_register_for_notification()`

### Implementation

This function will be implemented in `routing_table.c`

- lookup and fetch subscriber interested data entry
    - if data entry not found
        - create the data entry
        - data entry keys provided by the subscriber
        - make the data part NULL → because:
            - the publisher only can modify/add the data source
            - We will make new data entry, just to add subscriber to notification chain
- Make the notification chain element for the subscriber
    - initialize it
    - fill the subscriber properties in notification chain element:
        - `app_cb` subscriber computation function
        - `sub_id` subscriber id
    - We will not fill these subscriber properties
        - `key`
        - `key_size`
        - The reason for this, key filled already in the routing table data entry, the key it self stored in data source entry `dest_ip` and `mask`, if fill the notification chain element key it will be a redundant task.
    - call the notification chain registration API
- if fetched data exist and found
    - send notification to the subscriber, by calling the subscriber computation function
        - We will give the data entry to the subscriber by passing it as argument
        - the subscriber he will handle and decide what he will do with this data entry.
        - will give the subscriber the operation code, for further details.

# # Implementing Notification

When ever a publisher update to any data entry. Notification should be send to all subscriber that interested to that data entry.

We use `nfc_invoke_notif_chain()` API.
## Implementation
So we will send notification to subscribers when:

- Publisher update data entry
- Publisher delete data entry.

# Conclusion
As said, this note taken to summarize the course knowledge, so it may have some bugs, and dump implementation
This framework is very efficient and can be enhanced and used in larger project.
Learned a lot from this small project specially in how big project structured and designed, how communication between threads happen, and generic data structure implementation. I will try to extend this project to be used in further ideas.
Special thanks to @sachinites, for Udemy [**Multithreading & Thread Synchronization - C/C++**](https://www.udemy.com/course/multithreading_parta/#instructor-1) course, the motivation and the idea of this practice comes from him.